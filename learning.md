幂等 ：在数据不变的情况下，一个操作，无论执行多少次，结果都是一样的；幂等函数就是，任何时候调用，参数不变，结果不变

后台处理数据库业务逻辑：建立链接次数尽量少，多个请求尽量合并成一个请求，因为建立连接是比较费时的，损耗后台服务器，也损耗数据库服务器；
					  所以一个请求能完成的所有数据，就别分多次请求；用户端一个行为，最好是连接一次数据库

//需要一个本地数据库，一个测试数据库，分别用于本地开发和测试环境测试

数据库：mongodb【和redis类似，都是内存型数据库，先把数据放内存，然后再写磁盘里】【主要解决海量数据的访问效率问题，但它比较占资源，文件比较大，磁盘和内存需要较大】
    0.超级好用，易学，两天就看得七七八八了
	1.“nosql类型数据库”中的“文档存储”类型
	2.database【数据库】，collection【集合】，document【文档】，field【数据字段/域】，index【索引】，primary key【主键】
	3.基础：增删改查，
	  索引【提高查找速度】：如何制定高效的索引，是提升性能的核心；https://www.cnblogs.com/yu-hailong/p/7631572.html
	  					0.索引只要创建一遍，就会一直存在于数据库服务器的内存里，数据库更新，索引也会自动更新
	  					1.把集合按照特定field字段分组，其实就是把数据格式按照某些特定的key去排序，创造另一种便于查询和操作的数据格式
	  					2.索引可以看成另一种数据库中的数据，只是这个数据保存在内存中，但是操作数据的时候，索引也必须更新，就当成数据库的一部分
	  					3.索引可制定权重，搜索某个数据的时候，会按照关联索引的权重去查询，因为在内存，所以速度特别快，但是对内存要求高
	  					  
	  					4.如果不用索引，面对大批量的数据排序，数据库服务器会把用的所有数据全部塞到内存里面计算，MongoDB 将会报错 造成内存溢出，导致MongoDB报错 
	  					5.其实每一个集合内的文档，文档的“主键_id”就是它的默认索引，但基本查询不会用到这个字段的查询，索引需要自己创建索引

	  进阶：mapReduce【大批量数据处理工作分解成一个个单元执行，然后再把结果合并】：这个是核心，必须掌握【用js编写，并且基于js v8引擎解析】
	  	    mapReduce：https://www.cnblogs.com/boshen-hzb/p/10431295.html，说得非常好，其他人讲得都是垃圾
	  	    		   使用场景：复杂大型的数据操作，并返回集合数据，如果只是统计综合，平均值之类的，用聚合比较合适，因为较轻量级
	  	    			1.filter筛选，
	  	    			2.根据emit函数里的第一个参数进行分组，对应的值是第二个参数，分成若干组；
	  	    			3.对多个组执行map函数，每个组都调用reduce；
	  	    			4.map的组的key变成_id对应的值，map组的value【数组】，结果reduce函数里的计算，尝试value对应的值

	  	    聚合+管道【一般用户统计平均值，求和等遍历大批量数据求值的操作】
	  	    




	4.高级：分片【增加服务器，提高数据存储量和计算速度】，复本集（也就是集群）【也是有主库和从库，主库死了，从库自动顶上】，主从数据库【主库存储线上数据，从库每隔几秒从主库获取更新数据，和主库数据保持一致，主库数据库瘫了，直接用从库顶上，这个需要手动】
mongodb单个数据库的数据结构：所以mongodb的数据库集合，实际上就是一个JSON对象

	{
		db：{
			//db下一个对象，就是一个“集合”
			"collectionA":[{//一个对象就是一个文档
					_id:ObjectId("456321456321546"),
					name:"jeff",//一个key就是对应的field
					age:24
				},{//一个对象就是一个文档
					_id:ObjectId("456321456321546"),
					name:"jeff",//一个key就是对应的field
					age:24
				}],
			"collectionB":[]
		}
	}





数据库安全：
	1.防止而已大批量查询，数据库内存溢出。
	2.给可能的大批量查询制定索引，提高效率的同时防止内存溢出【索引也不能太多，不然也会造成内存溢出】


















论坛的数据库数据结构：数据库结构设计，很容易关联错误导致数据前后矛盾，毕业设计用到的一个软件可以检测这个问题【实体，主键，外键设置】
					最复杂的功能就是评论嵌套的设计：如何存档数据方便查询

{
	ab：{
		//users,articles,comments是三个集合，一般经常用到MapReduce命令来遍历一个集合，比如用MapReduce遍历users
		users:[{
			//下面是内容
			uid,
			userName,//帐号
			passward,//密码
			phone,
			name,//真实姓名
			age,
			sex,
			favName,//网名|昵称|花名【唯一，大家网名不能相互重复】
			charts:[{type,data}]//data是图标的数据，对数据格式的校验前端完成，后台和数据库都不做处理

			//下面是关联key：关联人，文章，说说|评论
			fans:[uid]//粉丝
			attention:[{uid,attentionLevel}]//关注哪些人
			favComment：[uid]//点赞了哪些评论|说说
			favArticle：[aid]//点赞了哪些文章
			article:[aid,aid....]//文章
			collect:[aid,aid...],//收藏
			comment:[cid]//写了哪些评论|说说
			msgboard:[cid]//留言板，谁给这个人留言了
		}],

		//文章的查询特别多，文章相对来说比“说说"少很多"，且有些字段也不一样，没必要放一个集合，逻辑上也说不通，性能上也不好
		articles:[{//业务逻辑处理的时候，要特别注意是“文章”|“说说”|留言

			//下面是内容
			aid,//唯一id
			time,//时间
			title,//标题
			content,//内容

			//下面是关联key
			tag:["desc1","desc2"....]//标签
			comment:[aid,aid]//评论：只有针对文章的评论，其他都没有
			uid,//谁写的 
			atuid,//作者@谁 
			faver：【uid】//点赞 
			relay:[uid,uid]//转发 
		}]

		//谁在什么时候对谁说了什么话，哪些人支持点赞
		comments:[{//注意，这个不光是相互评论；还有一个是个人主页留言板的第一层评论，

			//下面是内容
			cid,//唯一id
			time,
			content,

			//下面是关联key
			uid,//谁写的
			target:{//针对谁
				uid,//在某人留言板留言
				aid,//在某个文章下留言
				cid,//针对某个评论或说说留言
				noid//不针对任何人，文章，评论|说说；也就是自己发独立的说说
			}
			faver：【uid】//点赞
		}]

	}
}
		