// 最终的安全方案：
// 	1.用https，至少在传输这一层数据相对安全，站点防伪造【别人输入这个网址，必须返回自己的站点】
// 	  因为ssl证书是和域名或者ip绑定在一起的，对方访问这个域名，就必须返回你这个站点，否则就提示危险
// 	  https传输的时候的数据加密+防篡改，域名访问站点时候的站点校验【是否是真的站点】
// 	2.普通功能的登录态，用jwt验证操作；koa-jwt
// 	3.重要功能的登录态操作，用jwt结合数据库表【session信息记录在单独的数据库表中】 自己写逻辑
// 	  用一次性的jwt来实现重要功能的操作，让旧的jwt报废，生成新的jwt，用于下次验证
// 	4.用户登录用动态码技术，两次ajax请求，第一获取动态码，返回客户端后，
// 	  第二次自动带上用户的请求数据+动态码；客户端校验用户数据+动态码，然后确认通过
// 	  下次用户登录，老数据肯定不能用了，因为动态码变了，而且融合在请求数据里面，无法伪造

// 	//这个后续有空做
// 	5.所有的html，ajax请求，用通过ip+ua来设置防刷机策列，防止黑客用海量请求来“集中攻击服务器”
// 		5.0 缓存机制预防第一波恶意
// 		5.1 重要接口单独设置阈值
// 		5.2 每个用户一天内设置一个uuid，根据uuid设置，每1分,10 分，1 小时 阈值
// 		5.2 相同ip+ua设置单位时间内阈值：【如果】

// 	6.浏览器缓存机制需要详细阅读，理解后再设置


// 数据处理相关：
// 	1.encode，decode，base64：客户端字符转义，不然放在浏览器url里面太显眼了，这个是最基本的字符串转译
// 	2.字符串加签【hash加签等，防止篡改（一份加签，一份不加签，最后比对一部分加签后是否和另一个加签的一样）】：
// 				MD5【不管字符串多长，都能缩小成固定长度，确保唯一性，但是无法还原，所以常用在签名】
//                 HMAC SHA256：典型的签名算法。
// 	3.字符串加密和解密：对称加密【只有一个密钥】和非对称加密【公私钥】


// Base64有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法

/*
数据安全考虑点【HTTPS对下面安全都有特定的处理】：
	1.加密：防止数据被读取
	2.数据一致性：防止数据被篡改，用非对称加密中的密钥加签和解签【发送2分报文，一份用私钥加签，黑客只要篡改数据，解签对比就对不上】
		2.1最初级的是请求报文数据被篡改，站点内部请求，这个还可以用服务端加签来修补漏洞
		2.2最难的是整个站点被篡改，用户输入百度，返回的是谷歌的页面，这个只能用https才能预防
		   https是给站点证书，请求站点的时候，会请求站点证书验证站点，客户端接受返回信息都验证证书
		   在浏览器客户端层面进行了站点的真伪验证。
	3.身份认证：保证用户访问的是安全的有证书的网站；否则就提示站点不安全。

	https能保证浏览器数据加密后传出，到服务器那边接收，以及服务器那边传出，到浏览器客户端接受；之间的安全
	但是客户端被黑，没执行https的加密，或者记录用户输入的数据，这个不属于站点安全范畴
	站点页面被植入站外js，在站点内部出现的问题，包括客户端请求在https之前被截获，这个都是站点的安全问题

	jwt是在https上才能使用的技术，否则被拦截获取就毫无安全性可言。
	https是无法防范相同报文的请求伪造的，在相同的ip下，用相同的https报文请求；
	https是可以拦截的，只是它加密，加签，同时验证网站证书，但不能防止数据被拦截
	所以登陆验证需要客户端动态id，保证请求数据被拦截下次也无效



移动端不能用ip验证：因为如果手机断开wifi，用4G或者转到5G信号，ip都会变，ip不能作为判断登录态的一个参数



截取报文，然后同ip发送截取报文，模仿用户登录【虽然不知道报文内容，但是只要这个报文时用于登录或者登录态验证的，内容一样就可能鉴权通过】
	3.1：客户端向服务端发送请求的时候截取，然后在同一ip用相同报文请求服务器
	3.2：服务器向客户端发送登录态验证auth的时候，截取auth，然后在相同ip用这个auth请求服务器
	3.3：最最厉害的攻击：服务端向客户端发送auth的时候截取，然后打开网站，用自己真实帐号登录
	     同样也会返回服务端的auth，在返回的地方打断点，然后用之前截取的auth来覆盖自己的auth
	     接下来不管前端逻辑再怎么变，都是基于服务端auth的处理，然后赶在用户没有重新发送请求，
	     auth还没有失效的情况下，向服务端发送请求，这样服务端那边刷新了auth并返回给你最新的auth，
	     原来真实的用户再向服务端发送auth请求，会auth验证失败，需要用户重新登录，黑客这边
	     则获取了持续化登录态的auth权限，只要用户那边没有再登录把黑客的auth权限挤下来，
	     黑客就可以持续登录态操作
	3.4：http和https区别，https是如何保证报文安全方式截获的【本地js发送进入http|https通道之后的安全】
	     如果站点被js注入，那么http和https也没用，因为再发送报文之前，数据就被截获了
	     如果浏览器层面被黑客攻击，在浏览器加密https之前数据就被黑客截取，那https也没啥用：
	     https主要是站点提供一个证书和密钥给浏览器，浏览器验证没问题后就在用户和服务器之间搭建一个
	     私密的会话通道，内容全是加密的，所以在浏览器加密https之前，和服务器获取https报文解密之后，
	     这个范围之外的安全不在https安全防范之内，
	3.5：页面的html请求在返回的时候，被代理服务器截获，然后修改里面的js链接，误导用户操作输入用户名和密码
		 这样就可以获取用户资料。		




hash加密：常用的hash有md5和SHA256，主要功能类似数据的加签，主要用于鉴定数据是否被篡改的问题；md5不太安全


https:用到SSL证书，加密版的至少2千以上一年，同时https请求速度比http慢，
	  因为http只要tcp三次握手，3个包；https需要12个包，多了9个包，用于数据加密等一些列操作
	  详细流程见finalProject中的https请求流程图
	  其实它为了兼容所有客户端浏览器和服务器之间的统一通讯，多执行了几次密钥传递的请求
	  我自己的网站用模仿https的验证流程，站点前端页面和服务器之间通信自己加密和签名验证；
	  只要用户输入网址请求的是

	  https其实就是在http和tcp建立链接之间，加入了传输层安全性(TLS)或安全套接字层(SSL)
	  tls其实就是ssl的加强版，加强了ssl然后把ssl改名tls，有的用tls，有的用ssl
	  TLS 的密码套件比较规范，基本格式就是密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法
	  例如 ECDHE-ECDSA-AES256-GCM-SHA384，就是钥交换算法用ECDHE，签名算法用ECDSA....

程序员网站： stackoverflow



 用于登录态检验和用户注册登录
 用户注册：userName和passward，手机号,在后端产生一个唯一的uid；

			验证码短信发送的具体流程如下：
				1.用户在线填写手机号码，
				2.申请获取验证码网站、APP按照规则生成验证码
				3.APP将用户的手机号码和短信内容有短信平台提交到运营商通道
				4.通过运营商的发送规则评估
				5.运营商将指定内容发至指定手机号码
				6.用户收到短信，并在APP填写验证码，完成验证。



			svg-captcha的node插件用于图片验证码技术：
							注册和登录都需要用到验证码技术，防止机器人恶意刷机注册
							虽然要有手机号才能注册成功，但是机器人而已刷，每次都失败
							就非常占服务器资源。

	



			
			用户主流的交互流程：
						1.用户昵称具有唯一性，如果用户注册时没有填写，后台给用户默认用户名就是它的id，后期用户可修改用户名；
			 				用户名确保唯一性，同时昵称修改后其他粉丝仍然关注列表里仍然是你
						2.建站初期，用户名不容易冲突，可以放在非必填里面，人数上万以后，昵称就隐藏，防止注册反复冲突
			
			代码回滚和数据库回滚：
					1.代码库【前端和服务端都一样】被删了，怎么办：【每次发布，本地master和服务端都有代码，多人开发就更加安全，所以git不存在代码被删问题】
					2.数据库被删，怎么办？数据库实时备份，同时运行4个数据库，一个保持最新备份，一旦主库被删或出问题，立马自动切换到备用数据库
					  数据库是网站和公司的核心资产，数据库没了，等于啥都没了，所以需要至少2个数据库【物理分开，2个地址】，否则一旦出现灾难，数据库就全没了
					3.一个主库，1个替补库，替补2，一个备份库；主库出问题，替补库顶上，瞬间接盘，如果替补库在主库没有修复的时间内也出问题，
					  替补2顶上，作为临时主库，同时替补1和备份库都要实时跟随替补2，为什么需要一个备份库，因为替补1出问题，替补2 顶上的时候，
					  替补1跟随替补2需要一定的部署时间，这个时候如果替补2再出问题，那就没问知道最新的数据库了，所以备份库这个时候用于记录最新数据库
					  等替补2出问题了，备份库都用上了，基本替补1也就完成了跟随最新库的操作；持续吃恩替就是在3个非主库之间来回替换，主库交给程序员查询解决问题
				




			
			登录流程：【客户端信息无法篡改或伪造登录】
						注意1.这个是最核心的，因为走登录接口，如果黑客走登录接口的时候，截取了用户上次登录时用到的所有相同的cookie和ajax数据，能否被黑登录】【cookie设置httpOnly，secure，sameSite】
						注意2.如何防止机器狂刷登录【限制登录次数，同时用图片验证区分人机，或最直接地用短线验证码】

						0.点击登录，服务端添加动态码到cookie里面返还给客户端
						1.ajax请求带上服务端发过来的“cookie中的动态id”，再进行加密；服务器验证客户端ajax中的动态码信息和服务器动态码一致，才能通过,再验证登录【每次发送的动态id都不一样】
						2.这样的话，对方只有知道用户名，密码，动态id三个，才能用前端的公钥加密，否则就无法生成带有有效登录信息的auth，
						  而动态码，是每次点击请求的时候，从服务器临时产生并传送给客户端的动态码，没有长时间有效性，每次点击都设定一个新的值


						3.这个方法的核心原理：服务端只通过客户端的数据进行登录验证的话，如果之前登录验证通过，那这次只要客户端发送到服务端的
						  数据和之前的登录请求保持完全一样【cookie，ajax请求和请求头，请求地址，ip等】，就可以通过，因为服务端完全依赖客户端数据
						  所以再次登录肯定是通过的 ，如果不通过，那原来的用户也没法登录；所以服务端那边需要保存鉴别的动态码
						  每次请求到服务端，要校验上次客户端请求时服务端发给它的动态码，每次都不一样，所以哪怕黑客截取了上次的
						  数据，但这次动态码不一样，就通不过。这个方法的缺点是要执行两次ajax，保持最新且有效的动态码，动态码如果
						  是用户首次请求页面的时候获取的，服务器就要建立很长时间的长链接来维持这个动态码在服务器上的生命周期
						  就很耗费服务器资源，其次，如果用户长时间不用这个动态码，后端的动态码会失效，这样用户一段时间后点击登录，
						  就没法正常登录了。虽然使用两次ajax，但用户的感觉还是点击一次，中间通过ajax嵌套，实现3次握手【两次ajax请求】
						  第一次握手是告诉服务端，我要登录了，准备好动态码，然后服务器就准备了临时动态码
						  第二次握手是服务器告诉客户端，下次你登录的时候，要用这个动态id，服务器把动态码传给客户端
						  第三次握手是客户端把账号密码以及动态码打成一个值，让黑客无法伪造信息，因为就算知道动态码，但不知道帐号和密码
						  所以最终打成的那个值，肯定是本次登录唯一的，下次在用这个值就作废了，因为动态码失效了，
						  因为下次点击登录，又是重新开始，重启获取动态码，动态码的有效性只是在本地登录，本次登录验证失败
						  用户再点击登录，又是3次握手，又是新的动态码，上次截获的信息毫无用处；
						  这种登陆验证，黑客只能通过获取用户的帐号和密码这个源头，才能正常登录；获取加密的帐号和密码都不行
						  因为加密的帐号和密码是和动态码绑在一起的，无法单独提取出加密的用户名和密码；
						  如果非常熟悉网站的js逻辑，在js执行到ajax请求加密发送之前截取到用户的帐号和密码；
						  也就是在js代码流程中截取，那只有2中方法，一种是黑客完全控制了用户的客户端，能随意在某个地方停止截取
						  另一个是黑掉网站，然后在对应的js发送ajax之前插入自己的js代码，保存用户数据并发送；
						  也就是黑掉网站自己本身的js链接并伪造类似代码的js链接返还给客户端；这种都是js源头级别的风险
						  是最危险的，黑客能通过黑网站来实现js替换【这个网站端要做好防护】，另一个就最麻烦了
						  就是网站本身就没有危险，数据也是正确的，但是网站传资源给客户的时候，中间被其他服务器拦截
						  拦截后篡改js【复制原来的js，然后找出登录或者其他重要的相关功能的代码，修改好】，每次黑客服务器
						  只需要把篡改好的js链接【逻辑和原来js差不多，只修改部分】，代替成原来的js链接
						  因为script标签本身就跨域的原因，浏览器本身就没有好的屏蔽方案，总不能把所有外站js禁用吧。
						  面对中间的服务器拦截修改数据【ajax，html和html里面的js链接】，这里要防很难？？？？？？



			
			//session表作为一个集合，存储在数据库里面，并且需要创建session集合中对应的索引，因为登录态验证非常频繁
			登录态流程【核心时ip无法伪造】：	
						1.用户登陆后，服务端会用“uuid+用户名”生成一个唯一的key，把用户的ip，ua，userName， passward 合并生成一个auth;这样就在session中创建了键值对【键值对放数据库，以为分布式服务器的缘故，放单个服务器没有，无法总到统一验证】
						  然后把那个唯一和用户匹配的key保存到cookie中返还给客户端
						2.用户刷新页面执行ajax请求客户端的时候，客户端拿到之前的cookie，获取cookie的值，也就是之前session的键值对的key，
						3.服务端用这个key，去数据库中寻找session的键值对的key，如果匹配上；同时客户端的ip和ua+解析cookie获得的用户名和数据库中的key对应的ip和ua,用户名都对上了
						  那就可以确定是同一个人，鉴权通过；

						


			注册流程：【和登录的逻辑一样】
						0.后端发送动态id都用户端，注册时候，用户吗和密码之间添加动态id，然后加密发送给服务器【传送无法解密，也无法篡改，一篡改就变成无效信息，都断无法解码了出正确的格式】
						1.进入对应的api，获取用户基本信息，用户名，密码，动态id【时间戳，这个相当于签名】必须有，直接走登录的数据库流程
					 	2.返回ajax的注册成功信息给客户端，同时包含最新的动态id，注册就结束了

			
			！！！！！上面三个只是解决了客户端发送信息给服务端的验证问题，但是如果服务端把数据传给客户端，中间被截获并且修改数据，比如服务端给客户端的数据是一个手机5000，中间数据传到客服端之前价格被改成了5块
			验签：用户接受数据以后，被这个5块诱导去下单了，用户本地执行还有所有的全线，那么就被误导执行交易，所以客户端这边，需要拿一个签名，来验证服务端数据没有被篡改；
			验证签名的方式很简单，服务端准备2份相同的数据，给一份数据用私钥加签名【只有私钥能加签】，客户端受到信息后，对加签的那个字段的信息解签，然后和另一份数据对比，一样的话，就是数据没有篡改；
			只要不一样，那就是篡改了，客户端就知道了


			
			
			页面初始化流程：首次登录，ajax获取所有用户相关数据，然后相关个人数据的模块异步异步刷新。
						   后续刷新【不重要的本地缓存数据，不强求ajax】，服务端返回初始html，前端根据auth，执行初始化ajax请求，返回初始页面数据异步渲染

			退出登录流程：1.点击推出登录，删本地auth，然后走空数据页面的render：所以得分2个初始化

 			
 */



/*desc:所有安全相关的代码，全部放这里，供其他页面或公共调用
	1.添加动态验证码【时间戳】和验证，
	2.图片动态码验证【前端已经验证了，后端不验证，反正不是什么重要功能，防止机器刷而已】
	3.手机验证码封装，手机短线验证，
	4.登录态权限封装和验证，
	5.数据私钥解密，传送数据加签
	6.防机器人刷后端接口等
*/
const jsonwebtoken = require('jsonwebtoken');
const config = require("../../config");
const NodeRSA = require('node-rsa');


//前后端加密的密钥初始化；
function initEncrypt(app){
	
    var key = new NodeRSA({ b: 1024 });//公钥长度
    key.setOptions({ encryptionScheme: 'pkcs1' });//指定加密格式：因为jsencrypt使用这个格式加密的
    var publicKeyStr = key.exportKey('pkcs8-public');//制定输出格式：公钥字符串
    var privateKeyStr = key.exportKey('pkcs8-private');//制定输出格式：私钥字符串
    var publicKey = new NodeRSA(publicKeyStr);//用公钥字符串创建公钥
    var privateKey = new NodeRSA(privateKeyStr);
    publicKey.setOptions({ encryptionScheme: 'pkcs1' });//指定加密格式：因为jsencrypt使用这个格式加密的
    privateKey.setOptions({ encryptionScheme: 'pkcs1' });//指定加密格式：因为jsencrypt使用这个格式加密的
    app.encryptKey={publicKeyStr,privateKeyStr,publicKey,privateKey };
}


//验证jwt的登录态
function verifyJwt(context){
	let secret=config.auth.secret;
	let token=context.cookies.get("token");

	//加签和解签的secret必须是同一个,不然在回调函数中提示err,出现解签失败
    jsonwebtoken.verify(token, secret, function(err, decoded) {
    	// decoded是解签后获得的字段，里面包含个人自定义字段，同时可能出现下面的默认字段
  		// iss (issuer)：签发人
		// exp (expiration time)：过期时间
		// sub (subject)：主题
		// aud (audience)：受众
		// nbf (Not Before)：生效时间
		// iat (Issued At)：签发时间
		// jti (JWT ID)：编号
		debugger
        if (err) {
        	context.jwtVerified=false;
            /*
              err = {
                name: 'TokenExpiredError',
                message: 'jwt expired',
                expiredAt: 1408621000
              }
            */
        }else{
        	context.jwtVerified=true;
        	context.request.jwtData=decoded;//把token内数据放到request的jwtData自定义字段里面
        }
    });
}

module.exports = {
	init:function (app) {
		//return函数外面是服务器初始化的时候配置app的数据

		initEncrypt(app);
		


		//return函数内部，是每次页面和ajax请求获取对应的数据，在页面路由之前，可以拿到所有的数据，包括对应页面返回的数据
	    return function (context, next) {

	    	let {publicKeyStr}=context.app.encryptKey;
	    	//添加公钥到html页面【在html而页面里可以直接执行outPutPublicInfo，因为挂在scope上】
        	
		    context.cookies.set("authKey",Date.now(),Object.assign({},config.session,{sameSite:"",httpOnly:false}));
		    context.cookies.set("publicKey",encodeURIComponent(publicKeyStr),Object.assign({},config.session,{sameSite:"",httpOnly:false}));
		    verifyJwt(context);

		    return next()
	    };
	},
	addToken:function ({phoneNum , IP , ua }) {

		let secret=config.auth.secret;//"Bearer " +
        const token = jsonwebtoken.sign({phoneNum , IP , ua },secret , { expiresIn: '3h' }); // token 有效期为3小时
        this.cookies.set("token",token,{
            // domain: 'localhost', // 设置 cookie 的域
            // path: '/', // 设置 cookie 的路径
            maxAge: 3 * 60 * 60 * 1000, // cookie 的有效时间 ms
            // expires: new Date('2021-12-30'), // cookie 的失效日期，如果设置了 maxAge，expires 将没有作用
            httpOnly: true, // 是否要设置 httpOnly
            overwrite: true // 是否要覆盖已有的 cookie 设置
        });
	},

	// 解密数据
	getEncryptedData:function(context){
		let body=context.request.body;
	    if(body&&body.type==="encrypted"&&body.data){//前端以{data："机密字数据符串",type:"encrypted"}方式传过来
	        let privateKey=context.app.encryptKey.privateKey;//解密的私钥在服务器初始化的时候挂在app上

	        //原始的base64在网络传输的时候，+和/字符替换又是会出问题，所以前端自定义转码，后端再相同方式解码
	        let str=body.data;
	        str=str.replace(/\-/g,"+").replace(/\_/g,"/");
	        let encryptedData=privateKey.decrypt(str,"utf8");
	        return encryptedData;
	    }else{
	    	return {}
	    }
	}
}
