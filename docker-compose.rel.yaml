#mongo集群的yml【单机部署mongo集群，没有用到docker集群，如果要多个机器部署mongo集群，就需要用到docker集群来协调】
version: '3.5'
services: #下面全部放服务，每个服务名称代表一个docker容器，每个容器统一通过service名称来相互访问数据
  database: #注意，database，arbiter，slave三个是都是数据库，组成数据库集群，database是主节点，slave是从节点，arbiter是仲裁节点，关闭一个节点，另外一个节点会自动成为主节点
    image: mongo:4.4.15 #生成容器依赖的镜像名称和版本
    restart: always #容器重启策列，always表示无论如何都会重启
    ports: #端口映射，服务器端口【这个是对外访问的端口，docker外面可以通过这个端口来访问】：docker端口【这个就是程序的端口】
      - 27017:27017
    environment: #环境变量，各个镜像的环境变量各不相同，每个镜像都都会有自己的环境变量，实现这个镜像特定的功能，比如下面的tz是mong数据库镜像设置时区的变量，
      TZ: Asia/Shanghai #时区
      MONGO_INITDB_ROOT_USERNAME: jeffreychen  #数据库访问需要通过帐号密码验证，root权限访问的帐号
      MONGO_INITDB_ROOT_PASSWORD: out103496 #root权限访问的密码
    logging: #日志相关设置
      driver: "json-file"
      options:
        max-size: "204800K" #所有日志加起来的最大容量
        max-file: "100000" #日志文件的最大个数
    volumes: #数据挂载，用于数据本持久化保存
      - type: volume #挂载类型
        source: master-data  #数据文件保存的host地址
        target: /data/db #数据在容器里面的保存位置，以容器的根目录为根目录；这个路径和设置文件【.conf文件】的dbPath保持一直，容器创建以后，需要进入容器，然后执行 mongo --config  conf文件路径来制定config文件
      - type: volume
        source: master-configdb
        target: /data/configdb
      - type: volume
        source: master-log
        target: /data/log
      #- "./mongodb.key:/data/mongodb.key" #副本集之间通信需要用到的加密认证文件，需要在yml文件同一目录下创建mongodb.key文件，openssl rand -base64 756 -out ./mongodb.key；然后chmod 400 mongodb.key
    networks: #容器所属网络
      app-network: #属于app-network这个网络，这个网络的类型在下面的设置，top顶层设置公共的变量
    container_name: db-master #生成的容器的名称
    privileged: true #给生成的docker赋予root权限
    entrypoint: [ "mongod", "--replSet", "mongoset","--bind_ip_all" ]
    #command: mongod --replSet mongoset --keyFile /data/mongodb.key #command表示service程序启动完成以后，自动执行的命令；这里--replSet定义了副本集名称，--keyFile定义了副本集加密认证文件所在地址；
    # 副本集加密认证的文件，用于副本集之间的加密通信，需要提前在本机上创建，然后在改变该文件的所有者和所属组，改变它的读写权限
    # 1.创建加密认证文件  openssl rand -base64 756 -out ./mongodb.key
    # 2.修改文件的读写权限 chmod 400 mongodb.key
    # 3.修改文件的所属组【这一步很多技术文章都没写，不确定是否一定要这么做】，假如不设置，个人猜测可能会出现各种权限问题   chown 999:999 /data/mongodb.key
    # 添加完加密认证以后，执行这个yml，执行完成以后，进入主节点数据库【database1】，并添加数据库管理用户，会自动同步到其他副本集数据库【添加数据库管理员和之前单个数据添加管理员的流程一样】
  arbiter:
    image: mongo:4.4.15 #生成容器依赖的镜像名称和版本
    restart: always #容器重启策列，always表示无论如何都会重启
    ports: #端口映射，服务器端口【这个是对外访问的端口，docker外面可以通过这个端口来访问】：docker端口【这个就是程序的端口】
      - 27018:27017
    environment: #环境变量，各个镜像的环境变量各不相同，每个镜像都都会有自己的环境变量，实现这个镜像特定的功能，比如下面的tz是mong数据库镜像设置时区的变量，
      TZ: Asia/Shanghai #时区
      MONGO_INITDB_ROOT_USERNAME: jeffreychen  #数据库访问需要通过帐号密码验证，root权限访问的帐号
      MONGO_INITDB_ROOT_PASSWORD: out103496 #root权限访问的密码
    logging: #日志相关设置
      driver: "json-file"
      options:
        max-size: "204800K" #所有日志加起来的最大容量
        max-file: "100000" #日志文件的最大个数
    volumes: #数据挂载，用于数据本持久化保存
      - type: volume #挂载类型
        source: arbiter-data  #数据文件保存的host地址
        target: /data/db #数据在容器里面的保存位置，以容器的根目录为根目录
      - type: volume
        source: arbiter-configdb
        target: /data/configdb
      - type: volume
        source: arbiter-log
        target: /data/log
      #- "./mongodb.key:/data/mongodb.key"
    networks: #容器所属网络
      app-network: #属于app-network这个网络，这个网络的类型在下面的设置，top顶层设置公共的变量
    container_name: db-arbiter #生成的容器的名称
    privileged: true #给生成的docker赋予root权限
    entrypoint: [ "mongod", "--replSet", "mongoset","--bind_ip_all"] #以集群的方式运行启动，集群名称为mongoset
    #command: mongod --replSet mongoset --keyFile /data/mongodb.key #command表示service程序启动完成以后，自动执行的命令；这里--replSet定义了副本集名称，--keyFile定义了副本集加密认证文件所在地址；
  slave:
    image: mongo:4.4.15 #生成容器依赖的镜像名称和版本
    restart: always #容器重启策列，always表示无论如何都会重启
    ports: #端口映射，服务器端口【这个是对外访问的端口，docker外面可以通过这个端口来访问】：docker端口【这个就是程序的端口】
      - 27019:27017
    environment: #环境变量，各个镜像的环境变量各不相同，每个镜像都都会有自己的环境变量，实现这个镜像特定的功能，比如下面的tz是mong数据库镜像设置时区的变量，
      TZ: Asia/Shanghai #时区
      MONGO_INITDB_ROOT_USERNAME: jeffreychen  #数据库访问需要通过帐号密码验证，root权限访问的帐号
      MONGO_INITDB_ROOT_PASSWORD: out103496 #root权限访问的密码
    logging: #日志相关设置
      driver: "json-file"
      options:
        max-size: "204800K" #所有日志加起来的最大容量
        max-file: "100000" #日志文件的最大个数
    volumes: #数据挂载，用于数据本持久化保存
      - type: volume #挂载类型
        source: slave-data  #数据文件保存的host地址
        target: /data/db #数据在容器里面的保存位置，以容器的根目录为根目录
      - type: volume
        source: slave-configdb
        target: /data/configdb
      - type: volume
        source: slave-log
        target: /data/log
      #- "./mongodb.key:/data/mongodb.key"
    networks: #容器所属网络
      app-network: #属于app-network这个网络，这个网络的类型在下面的设置，top顶层设置公共的变量
    container_name: db-slave #生成的容器的名称
    privileged: true #给生成的docker赋予root权限
    entrypoint: [ "mongod", "--replSet", "mongoset","--bind_ip_all"]
    #command: mongod --replSet mongoset --keyFile /data/mongodb.key #command表示service程序启动完成以后，自动执行的命令；这里--replSet定义了副本集名称，--keyFile定义了副本集加密认证文件所在地址；
  web:
    build: . #build来自定义dockerfile文件夹位置和文件夹名称，这里没有设置build下面的属性，所以默认是在当前文件夹下的dockfile作为创建这个容器的dockerfile
    image: gpclub:v1 #用了build，这个image就是生成的自定义镜像的名称，如果没有build，那就是容器创建所依赖的镜像【从官网的镜像中获取】
    container_name: gp-web
    privileged: true
    #depends_on: #容器之间的依赖关系，这个web服务生成的容器就依赖于databse，所以他会在database这个服务启动完成后再执行web这个服务，默认的服务启动顺序是按照yml从上到下的顺序启动的
      #- database
    ports:
      - 80:10129
    networks:
      app-network:
  mongo-express:
    image: mongo-express:latest
    container_name: mongo-express
    restart: always
    privileged: true
    ports:
      - 8081:8081
    volumes_from:
      - database
    networks:
      app-network:
    environment:
      ME_CONFIG_OPTIONS_EDITORTHEME: 3024-night
      ME_CONFIG_MONGODB_ADMINUSERNAME: jeffreychen
      ME_CONFIG_MONGODB_ADMINPASSWORD: out103496
      ME_CONFIG_BASICAUTH_USERNAME: jeffreychen
      ME_CONFIG_BASICAUTH_PASSWORD: out103496
      ME_CONFIG_MONGODB_URL: "mongodb://jeffreychen:out103496@database:27017" #mongo-express连接数据库的url，指出了这个服务的数据来自于database这个服务启动的程序【database就是数据库服务程序】
networks:
  app-network: 
    driver: bridge #定义了app-network这个网络的类型，默认其实就是bridge
volumes: #这里定义了公共的数据卷，它们可以再不同的service中用到
  master-data:
  master-configdb:
  master-log:
  arbiter-data:
  arbiter-configdb:
  arbiter-log:
  slave-data:
  slave-configdb:
  slave-log:
